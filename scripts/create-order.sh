#!/bin/bash

# THIS IS AUTO-GENERATED BY setup_local_nodes.sh. ANY CHANGES HERE WILL LIKELY BE OVERWRITTEN

# Create a cross-chain order from origin to destination chain
set -e

# Load addresses from config
ORIGIN_TOKEN=$(grep -A 15 "\[chains.31337.contracts\]" config/local.toml | grep 'test_token' | cut -d'"' -f2)
ORIGIN_SETTLER=$(grep -A 15 "\[chains.31337.contracts\]" config/local.toml | grep '^settler' | cut -d'"' -f2)
ORIGIN_COMPACT=$(grep -A 15 "\[chains.31337.contracts\]" config/local.toml | grep 'the_compact' | cut -d'"' -f2)
ORIGIN_ORACLE=$(grep -A 15 "\[chains.31337.contracts\]" config/local.toml | grep 'oracle' | cut -d'"' -f2)
DEST_TOKEN=$(grep -A 15 "\[chains.31338.contracts\]" config/local.toml | grep 'test_token' | cut -d'"' -f2)
DEST_SETTLER=$(grep -A 15 "\[chains.31338.contracts\]" config/local.toml | grep 'output_settler' | cut -d'"' -f2)

# User and recipient addresses (user will deposit, solver will provide liquidity)
USER_ADDR="70997970C51812dc3A010C7d01b50e0d17dc79C8"    # Account #1 (user depositing)
SOLVER_ADDR="f39Fd6e51aad88F6F4ce6aB8827279cffFb92266"   # Account #0 (solver)
RECIPIENT_ADDR="3C44CdDdB6a900fa2b585dd299e03d12FA4293BC"       # Account #2 (recipient)
USER_PRIVATE_KEY="0x59c6995e998f97a5a0044966f0945389dc9e86dae88c7a8412f4603b6b78690d"  # Account #1 private key

echo "Creating cross-chain order with Compact escrow..."
echo "Origin Token: $ORIGIN_TOKEN"
echo "Origin Settler: $ORIGIN_SETTLER"
echo "Origin Compact: $ORIGIN_COMPACT"
echo "Origin Oracle: $ORIGIN_ORACLE"
echo "Destination Token: $DEST_TOKEN"
echo "Destination Settler: $DEST_SETTLER"
echo "User (depositor): 0x$USER_ADDR"
echo "Solver: 0x$SOLVER_ADDR"
echo "Recipient: 0x$RECIPIENT_ADDR"

# Amount to transfer (1 token)
AMOUNT="1000000000000000000"

# Step 1: User approves InputSettler7683 to spend tokens
echo "Step 1: User approves InputSettler7683 to spend tokens..."
~/.foundry/bin/cast send $ORIGIN_TOKEN \
  "approve(address,uint256)" \
  $ORIGIN_SETTLER \
  "1000000000000000000000000" \
  --rpc-url http://localhost:8545 \
  --private-key $USER_PRIVATE_KEY

# Create order data with destination chain information
FILL_DEADLINE=$(( $(date +%s) + 3600 ))  # 1 hour from now

# Build MandateOutput for destination chain using proper ABI encoding
# This should match the format used in the working single-chain order

# Convert values to hex format
AMOUNT_HEX=$(printf "%064x" $AMOUNT)
CHAIN_ID_HEX=$(printf "%08x" 31338)  # uint32 for chain ID

# Remove 0x prefix and pad addresses to 32 bytes
DEST_SETTLER_BYTES32="000000000000000000000000${DEST_SETTLER:2}"
DEST_TOKEN_BYTES32="000000000000000000000000${DEST_TOKEN:2}"
RECIPIENT_BYTES32="000000000000000000000000${RECIPIENT_ADDR}"

# Create complete MandateERC7683 struct like the working single-chain version
ORDER_DATA="0x"

# Offset to struct
ORDER_DATA="${ORDER_DATA}0000000000000000000000000000000000000000000000000000000000000020"

# expiry (uint32 padded to 32 bytes) - 1 hour from now
EXPIRY=$(( $(date +%s) + 3600 ))
ORDER_DATA="${ORDER_DATA}$(printf '%064x' $EXPIRY)"

# localOracle (use AlwaysYesOracle address)
ORACLE_BYTES32="000000000000000000000000${ORIGIN_ORACLE:2}"
ORDER_DATA="${ORDER_DATA}${ORACLE_BYTES32}"

# offset to inputs array (0x80 = 128 bytes from struct start)
ORDER_DATA="${ORDER_DATA}0000000000000000000000000000000000000000000000000000000000000080"

# offset to outputs array (0xe0 = 224 bytes from struct start: 128 + 32 + 64)
ORDER_DATA="${ORDER_DATA}00000000000000000000000000000000000000000000000000000000000000e0"

# inputs array: 1 input
ORDER_DATA="${ORDER_DATA}0000000000000000000000000000000000000000000000000000000000000001"

# Input struct: (token, amount)
# token (uint256) - origin token as uint256
ORIGIN_TOKEN_BYTES32="000000000000000000000000${ORIGIN_TOKEN:2}"
ORDER_DATA="${ORDER_DATA}${ORIGIN_TOKEN_BYTES32}"

# amount - 1 token
ORDER_DATA="${ORDER_DATA}${AMOUNT_HEX}"

# outputs array: 1 output
ORDER_DATA="${ORDER_DATA}0000000000000000000000000000000000000000000000000000000000000001"

# offset to first output (0x20 = 32 bytes from outputs array start)
ORDER_DATA="${ORDER_DATA}0000000000000000000000000000000000000000000000000000000000000020"

# MandateOutput struct:
# oracle (bytes32) - zero for no oracle
ORDER_DATA="${ORDER_DATA}0000000000000000000000000000000000000000000000000000000000000000"

# settler (bytes32) - use the destination settler address for cross-chain
ORDER_DATA="${ORDER_DATA}${DEST_SETTLER_BYTES32}"

# chainId - destination chain (31338)
ORDER_DATA="${ORDER_DATA}00000000000000000000000000000000000000000000000000000000$CHAIN_ID_HEX"

# token (bytes32) - destination token
ORDER_DATA="${ORDER_DATA}${DEST_TOKEN_BYTES32}"

# amount - 1 token
ORDER_DATA="${ORDER_DATA}${AMOUNT_HEX}"

# recipient (bytes32)
ORDER_DATA="${ORDER_DATA}${RECIPIENT_BYTES32}"

# offset to call data (0x100 = 256 bytes from output struct start)
ORDER_DATA="${ORDER_DATA}0000000000000000000000000000000000000000000000000000000000000100"

# offset to context data (0x120 = 288 bytes from output struct start)
ORDER_DATA="${ORDER_DATA}0000000000000000000000000000000000000000000000000000000000000120"

# call data - empty (length = 0)
ORDER_DATA="${ORDER_DATA}0000000000000000000000000000000000000000000000000000000000000000"

# context data - empty (length = 0)
ORDER_DATA="${ORDER_DATA}0000000000000000000000000000000000000000000000000000000000000000"

# The EIP-712 typehash for MandateERC7683
ORDER_DATA_TYPE="0x532668680e4ed97945ec5ed6aee3633e99abe764fd2d2861903dc7c109b00e82"

# Step 3: User creates the cross-chain intent order
echo "Step 3: User creates cross-chain intent order..."
echo "Order data length: ${#ORDER_DATA}"
echo "Fill deadline: $FILL_DEADLINE"
echo "Origin settler: $ORIGIN_SETTLER"
echo ""
echo "Note: This order represents a user's intent to move tokens cross-chain."
echo "Tokens are now escrowed in The Compact and the order signals to solvers"
echo "that they can provide liquidity on the destination chain and claim the"
echo "escrowed tokens after fulfillment."
echo ""

# Note: InputSettler7683.open() will pull tokens from user via approval
~/.foundry/bin/cast send $ORIGIN_SETTLER \
  "open((uint32,bytes32,bytes))" \
  "($FILL_DEADLINE,$ORDER_DATA_TYPE,$ORDER_DATA)" \
  --rpc-url http://localhost:8545 \
  --private-key $USER_PRIVATE_KEY

echo "Cross-chain order created successfully!"
